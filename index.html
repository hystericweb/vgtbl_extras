<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Tabela</title>
<style>
  :root{
    --maxw: 1200px;
    --radius: 6px;
    --border: 1px;
    --space-1: 6px;
    --space-2: 10px;
    --space-3: 16px;
    --space-4: 24px;
    --space-5: 32px;
    --space-6: 48px;
    --bg-hover: rgba(255, 255, 255, 0.1);
    --fg: #fff;
    --bd: #555;
    --letter-bg: #2a2a2a;
    --letter-hover-bg: #404040;
    --accent: #9ec1ff;
  }

  *{ box-sizing: border-box; }

  html, body {
    height: auto;
    overflow-x: hidden;
    overflow-y: visible;
  }

  body{
    font-family: 'Roboto', monospace;
    margin: 0;
    color: var(--fg);
    padding-inline: clamp(32px, 6vw, 96px);
    padding-block: 16px;
    background: transparent;
  }

  .wrap{
    max-width: var(--maxw);
    margin-inline: auto;
    width: 100%;
    background: #1a1a1a;
    border-radius: 16px;
    padding: var(--space-5);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }

  /* Pasek informacyjny */
  #loading, #error {
    font-weight: 500;
    font-size: clamp(12px, 2.5vw, 18px);
    text-align: center;
    margin: var(--space-5) 0;
    color: var(--fg);
    font-family: 'Roboto', Arial, sans-serif;
  }
  #error{ color: #ff6b6b; }

  .table-scroll{
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  table{
    width: 100%;
    border-collapse: separate;
    border-spacing: 0 var(--space-4);
    min-width: 100%;
    table-layout: fixed;
  }

  th, td{
    border: none;
    padding: clamp(14px, 2vw, 30px);
    font-weight: normal;
    font-size: clamp(14px, 1.8vw, 20px);
    background: transparent;
    min-height: 44px;
    vertical-align: middle;
    white-space: nowrap;
    overflow: visible;
  }

  tr{
    transition: background-color .15s ease;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    margin-bottom: 8px;
  }
  tr:hover {
    cursor: pointer;
    background: rgba(255, 255, 255, 0.1);
  }

  tr[tabindex]:focus-visible {
    outline: 2px solid #4a9eff;
    outline-offset: 2px;
  }

  @media (max-width: 768px){
    table{ border-spacing: 0 var(--space-3); }
  }
  @media (max-width: 480px){
    table{ border-spacing: 0 var(--space-2); }
    th, td{ padding: clamp(6px, 3vw, 16px); }
  }

  /* ====== Letter tiles (default ≥600px) ====== */
  .magnet-text{
    display: inline-block;
    margin: 1px;
    padding: 4px 6px;
    background: var(--letter-bg);
    color: var(--fg);
    border-radius: 4px;
    font-weight: bold;
    min-width: 16px;
    text-align: center;
    transition: transform 0.2s ease, background 0.2s ease;
    will-change: transform;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }
  .magnet-text:hover { background: var(--letter-hover-bg); transform: translateY(-1px); }
  .magnet-space { display: inline-block; width: 12px; }

  /* ====== Word blocks (≤600px) ====== */
  @media (max-width: 600px){
    table { table-layout: auto; }

    th, td{
      white-space: normal;
      line-height: 1.35;
      font-size: clamp(16px, 4.2vw, 18px);
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    /* Word pill */
    .magnet-word{
      display: inline-block;
      margin: 2px 6px 2px 0;              /* odstęp między „klockami” */
      padding: 6px 10px;
      background: var(--letter-bg);
      border-radius: 999px;               /* pigułka */
      font-weight: 700;
      transition: transform 0.18s ease, background 0.18s ease;
      box-shadow: 0 1px 2px rgba(0,0,0,.25);
      vertical-align: baseline;
    }
    .magnet-word:hover { background: var(--letter-hover-bg); transform: translateY(-1px); }

    /* Hide letter styling if any sneaks in on mobile */
    .magnet-text, .magnet-space { display: none !important; }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce){
    .magnet-text, .magnet-word { transform: none !important; transition: none !important; }
  }

  /* ====== Compact vertical date badge ====== */
  .date-compact{
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    line-height: 1;
    background: #111a;
    border: 1px solid #2a2a2a;
    border-radius: 10px;
    padding: 6px 10px;
    min-width: 42px;
    box-shadow: 0 1px 2px rgba(0,0,0,.25);
  }
  .date-compact .day{
    font-size: clamp(18px, 2.6vw, 22px);
    font-weight: 800;
    letter-spacing: 0.5px;
  }
  .date-compact .month{
    font-size: clamp(10px, 1.6vw, 12px);
    font-weight: 700;
    opacity: 0.9;
    letter-spacing: 0.6px;
    margin-top: 2px;
  }

  /* On very small screens, make the date a bit tighter */
  @media (max-width: 600px){
    .date-compact{
      padding: 6px 8px;
      min-width: 38px;
    }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div id="loading">Ładowanie…</div>
    <div id="error" style="display:none;">Błąd ładowania danych</div>

    <div class="table-scroll">
      <table id="dataTable" style="display:none;">
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

<script>
  /* ===== Helpers ===== */

  // Random but subtle rotation (letters on desktop, words on mobile)
  function randomRotation(maxDeg){
    const range = maxDeg * 2;
    return (Math.random() * range) - maxDeg; // -max..+max
  }

  function isNarrow(){ return (typeof window !== 'undefined') && window.innerWidth <= 600; }

  // Render per-letter tiles (desktop / wide)
  function renderLetters(text){
    return String(text ?? '').split('').map(char=>{
      if(char === ' ') return '<span class="magnet-space"></span>';
      const rotation = randomRotation(1.5);
      return `<span class="magnet-text" style="transform: rotate(${rotation}deg);">${escapeHTML(char)}</span>`;
    }).join('');
  }

  // Render word pills (mobile / narrow)
  function renderWords(text){
    // Split on whitespace, collapse multiples; keep only words and render gaps via margins
    const words = String(text ?? '').trim().split(/\s+/);
    return words.map(w=>{
      const rot = randomRotation(1.0);
      return `<span class="magnet-word" style="transform: rotate(${rot}deg);">${escapeHTML(w)}</span>`;
    }).join('');
  }

  function applyBlockyText(text){
    return isNarrow() ? renderWords(text) : renderLetters(text);
  }

  // Escape for HTML injection safety
  function escapeHTML(s){
    return String(s)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#039;');
  }

  /* ===== Date detection & formatting ===== */

  // Try to parse common date formats and return { day: '07', mon: 'SEP', iso: '2025-09-07' } or null
  function parseDateLoose(s){
    if(!s) return null;
    const str = String(s).trim();

    // Normalize separators
    const isoLike = /^(\d{4})[-/\.](\d{1,2})[-/\.](\d{1,2})$/;         // 2025-09-07, 2025/9/7, 2025.09.07
    const euLike  = /^(\d{1,2})[-/\.](\d{1,2})[-/\.](\d{2,4})$/;        // 7-9-2025, 07.09.25
    const usLike  = /^(\d{1,2})[-/\.](\d{1,2})[-/\.](\d{2,4})$/;        // 9/7/2025 (same shape as euLike; we assume EU by default)

    let y, m, d;

    if(isoLike.test(str)){
      const [,yy, mm, dd] = str.match(isoLike);
      y = +yy; m = +mm; d = +dd;
    } else if(euLike.test(str)){
      const [,dd, mm, yy] = str.match(euLike);
      d = +dd; m = +mm; y = (String(yy).length===2 ? (2000 + +yy) : +yy);
    } else {
      // Try Date constructor as fallback (handles Month names)
      const tryD = new Date(str);
      if(!isNaN(tryD)){
        y = tryD.getFullYear(); m = tryD.getMonth()+1; d = tryD.getDate();
      } else {
        return null;
      }
    }

    if(m<1 || m>12 || d<1 || d>31 || y<1900 || y>3000) return null;

    const monthStr = new Date(y, m-1, d).toLocaleString('en-US', { month: 'short' }).toUpperCase(); // 3-letter EN abbrev
    const dayStr = String(d).padStart(2,'0');

    // Produce a normalized ISO for aria-label / title
    const iso = `${y}-${String(m).padStart(2,'0')}-${dayStr}`;
    return { day: dayStr, mon: monthStr, iso };
  }

  function renderDateCompact(dateStr){
    const p = parseDateLoose(dateStr);
    if(!p) return null;
    const {day, mon, iso} = p;
    // aria-label for screen readers: keep original string but provide normalized too
    return `
      <span class="date-compact" aria-label="${escapeHTML(dateStr)} (${iso})" title="${escapeHTML(dateStr)}">
        <span class="day">${day}</span>
        <span class="month">${mon}</span>
      </span>
    `;
  }

  /* ===== CSV parser (handles quotes & commas) ===== */
  function parseCSV(csvText){
    const rows = [];
    let i = 0, field = '', inQuotes = false, row = [];
    while(i < csvText.length){
      const c = csvText[i];
      if(c === '"'){
        if(inQuotes && csvText[i+1] === '"'){ field += '"'; i++; }
        else { inQuotes = !inQuotes; }
      } else if(c === ',' && !inQuotes){
        row.push(field); field = '';
      } else if((c === '\n' || c === '\r') && !inQuotes){
        if(field.length || row.length){ row.push(field); rows.push(row); }
        field = ''; row = [];
        if(c === '\r' && csvText[i+1] === '\n') i++;
      } else {
        field += c;
      }
      i++;
    }
    if(field.length || row.length){ row.push(field); rows.push(row); }
    return rows;
  }

  /* ===== Data loading & rendering ===== */
  async function loadData(){
    const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQM_hD_qj2loea8TYCQL_QEGnIs2G437HniXMT3UJ5IDc8Grr0qrtMnEzd1cZjOqQtfqPv7RSN1OkhU/pub?gid=0&single=true&output=csv';
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    try{
      const res = await fetch(csvUrl, { cache: 'no-store' });
      if(!res.ok) throw new Error('HTTP ' + res.status);
      const csvText = await res.text();
      const rows = parseCSV(csvText);
      displayTable(rows);
      loadingEl.style.display = 'none';
    }catch(e){
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      console.error(e);
    }
  }

  function displayTable(rows){
    const table = document.getElementById('dataTable');
    const tbody = document.getElementById('tableBody');
    tbody.innerHTML = '';

    if(rows.length > 1){
      for(let i = 1; i < rows.length; i++){
        const rowData = rows[i];
        if(!rowData || rowData.length === 0) continue;

        const tr = document.createElement('tr');
        tr.setAttribute('tabindex', '0');

        const linkUrl = (rowData[rowData.length - 1] || '').trim();
        if(linkUrl){
          tr.addEventListener('click', ()=> window.open(linkUrl, '_blank', 'noopener'));
          tr.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Enter' || ev.key === ' '){
              ev.preventDefault();
              window.open(linkUrl, '_blank', 'noopener');
            }
          });
        }

        for(let j = 0; j < rowData.length - 1; j++){
          const td = document.createElement('td');
          const cell = rowData[j] || '';

          // 1) Try date compact renderer
          const dateHTML = renderDateCompact(cell);
          if(dateHTML){
            td.innerHTML = dateHTML;
          } else {
            // 2) Otherwise render as blocky text (letters on wide, words on narrow)
            td.innerHTML = applyBlockyText(cell);
          }

          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }
    table.style.display = 'table';
    postResize();
  }

  /* Resize messaging for embedded scenarios */
  function postResize(){
    const height = document.documentElement.scrollHeight;
    if(window.parent && window.parent !== window){
      try{
        window.parent.postMessage({ type: 'resize', height }, '*');
      }catch(e){ /* ignore cross-origin */ }
    }
  }
  function debounce(fn, wait=150){
    let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(null,args), wait); };
  }

  window.addEventListener('load', ()=>{
    loadData();

    window.addEventListener('resize', debounce(()=>{
      // Re-render text blocks on mode switch between narrow/wide
      // (Optional optimization: only if threshold crossed)
      // For simplicity, we re-run display to refresh word/letter mode
      const table = document.getElementById('dataTable');
      const tbody = document.getElementById('tableBody');
      // Rebuild by reading original text back is complex; instead, reload CSV.
      // If you prefer not to refetch, store parsed rows globally.
      // Here we store once:
    }, 150));

    if('ResizeObserver' in window){
      const ro = new ResizeObserver(debounce(postResize, 50));
      ro.observe(document.body);
    }else{
      setInterval(postResize, 500);
    }
  });

  // Optional: cache rows to avoid refetch on resize re-render
  // (Keeping it simple — add if you want live switching without reload)
</script>
</body>
</html>
