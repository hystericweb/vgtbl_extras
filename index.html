<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Tabela</title>
<style>
  :root{
    --maxw: 1200px;                 /* szerokość treści */
    --radius: 4px;
    --border: 1px;
    --space-1: 6px;
    --space-2: 10px;
    --space-3: 16px;
    --space-4: 24px;
    --space-5: 32px;
    --space-6: 48px;
    --bg-hover: rgba(255, 255, 255, 0.1);
    --fg: #fff;
    --bd: #555;
    --letter-bg: #2a2a2a;
    --letter-hover-bg: #404040;
  }

  *{ box-sizing: border-box; }

  html, body {
    height: auto;
    overflow-x: hidden;
    overflow-y: visible;
  }

  body{
    font-family: 'Courier New', monospace;
    margin: 0;
    color: var(--fg);
    /* większe marginesy po bokach + responsywne: min 32px, rośnie do 96px */
    padding-inline: clamp(32px, 6vw, 96px);
    padding-block: 16px;
    background: transparent;
  }

  .wrap{
    max-width: var(--maxw);
    margin-inline: auto; /* wyrównanie i duże marginesy po bokach */
    width: 100%;
    background: #1a1a1a;
    border-radius: 16px;
    padding: var(--space-5);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }

  /* Pasek informacyjny */
  #loading, #error {
    font-weight: 500;
    font-size: clamp(12px, 2.5vw, 18px);
    text-align: center;
    margin: var(--space-5) 0;
    color: var(--fg);
    font-family: 'Roboto', Arial, sans-serif;
  }
  #error{ color: #ff6b6b; }

  /* Kontener przewijania dla tabeli na małych ekranach */
  .table-scroll{
    width: 100%;
    overflow-x: auto;     /* gdy kolumny się nie mieszczą, pojawi się scroll */
    -webkit-overflow-scrolling: touch;
  }

  table{
    width: 100%;
    border-collapse: separate;
    border-spacing: 0 var(--space-4);
    min-width: 100%;       /* zostaje, ale mamy też poziomy scroll w razie W */
    table-layout: fixed;   /* stabilne szerokości i ellipsy działają przewidywalnie */
  }

  th, td{
    border: none;
    padding: clamp(14px, 2vw, 30px);
    font-weight: normal;
    font-size: clamp(14px, 1.8vw, 20px);
    background: transparent;
    min-height: 44px;
    vertical-align: middle;
    white-space: nowrap;      /* domyślnie pojedyncza linia… */
    overflow: visible;
  }

  tr{
    transition: background-color .15s ease;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    margin-bottom: 8px;
  }
  tr:hover {
    cursor: pointer;
    background: rgba(255, 255, 255, 0.1);
  }

  /* Widoczny fokus dla nawigacji klawiaturą */
  tr[tabindex]:focus-visible {
    outline: 2px solid #4a9eff;
    outline-offset: 2px;
  }

  /* Responsive adjustments - maintain word integrity */
  @media (max-width: 768px){
    table{ border-spacing: 0 var(--space-3); }
  }

  @media (max-width: 480px){
    table{ border-spacing: 0 var(--space-2); }
    th, td{ padding: clamp(6px, 3vw, 16px); }
  }

  /* Oszczędzanie ruchu – wyłącz rotację „magnesu" jeśli użytkownik woli mniej animacji */
  @media (prefers-reduced-motion: reduce){
    .magnet-text{ transform: none !important; }
  }

  .magnet-text{
    display: inline-block;
    margin: 1px;
    padding: 4px 6px;
    background: var(--letter-bg);
    color: var(--fg);
    border-radius: var(--radius);
    font-weight: bold;
    min-width: 16px;
    text-align: center;
    transition: all 0.2s ease;
    will-change: transform;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  .magnet-text:hover {
    background: var(--letter-hover-bg);
    transform: translateY(-1px);
  }

  /* Space character styling */
  .magnet-space {
    display: inline-block;
    width: 12px;
  }

  /* Airport terminal styling for rows */
  tr:hover .magnet-word {
    background: var(--letter-hover-bg);
    transform: translateY(-1px);
  }
</style>
</head>
<body>
  <div class="wrap">
    <div id="loading">Ładowanie…</div>
    <div id="error" style="display:none;">Błąd ładowania danych</div>

    <div class="table-scroll">
      <table id="dataTable" style="display:none;">
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

<script>
  // Losowa, ale subtelna rotacja znaków
  function applyMagnetEffect(text){
    return String(text ?? '').split('').map(char=>{
      if(char === ' ') return '<span class="magnet-space"></span>';
      // mniejszy zakres dla lepszej czytelności
      const rotation = (Math.random() - 0.5) * 3; // -1.5° do +1.5°
      return `<span class="magnet-text" style="transform: rotate(${rotation}deg);">${char}</span>`;
    }).join('');
  }

  // Solidniejsze parsowanie CSV (cudzysłowy + przecinki w polach)
  function parseCSV(csvText){
    const rows = [];
    let i = 0, field = '', inQuotes = false, row = [];
    while(i < csvText.length){
      const c = csvText[i];
      if(c === '"'){
        if(inQuotes && csvText[i+1] === '"'){ field += '"'; i++; } // ucieczka ""
        else { inQuotes = !inQuotes; }
      } else if(c === ',' && !inQuotes){
        row.push(field); field = '';
      } else if((c === '\n' || c === '\r') && !inQuotes){
        if(field.length || row.length){ row.push(field); rows.push(row); }
        field = ''; row = [];
        // obsłuż CRLF
        if(c === '\r' && csvText[i+1] === '\n') i++;
      } else {
        field += c;
      }
      i++;
    }
    if(field.length || row.length){ row.push(field); rows.push(row); }
    return rows;
  }

  async function loadData(){
    const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQM_hD_qj2loea8TYCQL_QEGnIs2G437HniXMT3UJ5IDc8Grr0qrtMnEzd1cZjOqQtfqPv7RSN1OkhU/pub?gid=0&single=true&output=csv';
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    try{
      const res = await fetch(csvUrl, { cache: 'no-store' });
      if(!res.ok) throw new Error('HTTP ' + res.status);
      const csvText = await res.text();
      const rows = parseCSV(csvText);
      displayTable(rows);
      loadingEl.style.display = 'none';
    }catch(e){
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      console.error(e);
    }
  }

  function displayTable(rows){
    const table = document.getElementById('dataTable');
    const tbody = document.getElementById('tableBody');
    tbody.innerHTML = '';

    if(rows.length > 1){
      for(let i = 1; i < rows.length; i++){
        const rowData = rows[i];
        if(!rowData || rowData.length === 0) continue;

        const tr = document.createElement('tr');
        // dostępność: pozwól fokusować wiersz i otwierać klawiszem
        tr.setAttribute('tabindex', '0');

        const linkUrl = (rowData[rowData.length - 1] || '').trim();

        if(linkUrl){
          tr.addEventListener('click', ()=> window.open(linkUrl, '_blank', 'noopener'));
          tr.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Enter' || ev.key === ' '){
              ev.preventDefault();
              window.open(linkUrl, '_blank', 'noopener');
            }
          });
        }

        for(let j = 0; j < rowData.length - 1; j++){
          const td = document.createElement('td');
          td.innerHTML = applyMagnetEffect(rowData[j] || '');
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }
    table.style.display = 'table';
    // po wyrenderowaniu – dopasuj wysokość osadzenia
    postResize();
  }

  // Lepsze dostosowanie wysokości do osadzającej ramki
  function postResize(){
    const height = document.documentElement.scrollHeight;
    if(window.parent && window.parent !== window){
      try{
        window.parent.postMessage({ type: 'resize', height }, '*');
      }catch(e){
        // cross-origin – po prostu zignoruj
      }
    }
  }

  // Debounce dla eventów resize
  function debounce(fn, wait=150){
    let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(null,args), wait); };
  }

  window.addEventListener('load', ()=>{
    loadData();

    // Reaguj na zmiany rozmiaru okna
    window.addEventListener('resize', debounce(postResize, 150));

    // Obserwuj zmiany treści (np. po doładowaniu tabeli)
    if('ResizeObserver' in window){
      const ro = new ResizeObserver(debounce(postResize, 50));
      ro.observe(document.body);
    }else{
      // fallback – okresowe sprawdzenie
      setInterval(postResize, 500);
    }
  });
</script>
</body>
</html>
